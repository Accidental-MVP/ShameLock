const blockedSites = ["youtube.com", "twitter.com", "reddit.com"];

let timerInterval;
let lastShameTime = 0;
const SHAME_DEBOUNCE = 5000; // 5 seconds between shame logs

// Function to log failure to GitHub
async function logFailure(site, time) {
  const { githubToken, githubUsername } = await chrome.storage.local.get(["githubToken", "githubUsername"]);
  let GITHUB_USERNAME = githubUsername;
  const TOKEN = githubToken;
  const REPO_NAME = "shame-log";
  const FILE_PATH = "FAIL_LOG.md";
  const date = new Date().toISOString().split("T")[0];
  const newEntry = `- ${date} â€“ Visited ${site} at ${time}\n`;
  const issueTitle = `Failed to focus: ${site} at ${time}`;
  const issueBody = `Visited ${site} during focus session at ${time}.\nShame.`;

  // If username isn't cached, fetch it now
  if (!GITHUB_USERNAME) {
    const userRes = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `token ${TOKEN}`,
        Accept: "application/vnd.github.v3+json"
      }
    });

    const userData = await userRes.json();
    GITHUB_USERNAME = userData.login;
    chrome.storage.local.set({ githubUsername: GITHUB_USERNAME });
  }

  // Check if repo exists
  const repoRes = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}`, {
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    }
  });

  if (repoRes.status === 404) {
    // Create the repo
    await fetch("https://api.github.com/user/repos", {
      method: "POST",
      headers: {
        Authorization: `token ${TOKEN}`,
        Accept: "application/vnd.github.v3+json"
      },
      body: JSON.stringify({
        name: REPO_NAME,
        description: "Autogenerated shame log",
        private: false,
        auto_init: true // Initialize with a README
      })
    });
  } else if (repoRes.status !== 200) {
    console.error("Failed to check/create repo:", await repoRes.text());
    return;
  }

  // Step 1: Create a GitHub issue
  await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/issues`, {
    method: "POST",
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    },
    body: JSON.stringify({
      title: issueTitle,
      body: issueBody
    })
  });

  // Step 2: Fetch FAIL_LOG.md or prepare to create it
  const fileRes = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FILE_PATH}`, {
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    }
  });

  let content = "# FAIL LOG\n\n";
  let sha = null;

  if (fileRes.status === 200) {
    const fileData = await fileRes.json();
    try {
      content = atob(fileData.content);
      sha = fileData.sha;
    } catch (err) {
      console.error("Failed to decode existing FAIL_LOG.md:", err);
      return;
    }
  } else if (fileRes.status !== 404) {
    console.error("GitHub file fetch failed:", await fileRes.text());
    return;
  }

  const updatedContent = btoa(unescape(encodeURIComponent(content + newEntry)));

  await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FILE_PATH}`, {
    method: "PUT",
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    },
    body: JSON.stringify({
      message: `log: failed focus on ${site}`,
      content: updatedContent,
      sha
    })
  });

  // Notify popup about shame (if it's open)
  try {
    chrome.runtime.sendMessage({
      action: "shameLogged",
      site: site,
      time: time
    }, () => {
      if (chrome.runtime.lastError) {
        // Popup is closed, that's okay
      }
    });
  } catch (e) {
    // Popup is closed, that's okay
  }
}

// Message handling
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "startFocus") {
    const minutes = message.duration;
    const totalDuration = minutes * 60;
    const endTime = Date.now() + (totalDuration * 1000);
    
    // Store timer state
    chrome.storage.local.set({
      focusEndTime: endTime,
      totalDuration: totalDuration
    });
    
    // Clear any existing timer
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    
    // Start new timer
    timerInterval = setInterval(async () => {
      const { focusEndTime } = await chrome.storage.local.get("focusEndTime");
      if (!focusEndTime) {
        clearInterval(timerInterval);
        return;
      }

      const now = Date.now();
      const timeLeft = Math.max(0, focusEndTime - now);
      
      // Update any open popups (if they exist)
      try {
        chrome.runtime.sendMessage({
          action: "timerUpdate",
          timeLeft: timeLeft
        }, () => {
          if (chrome.runtime.lastError) {
            // Popup is closed, that's okay
          }
        });
      } catch (e) {
        // Popup is closed, that's okay
      }
      
      if (timeLeft === 0) {
        clearInterval(timerInterval);
        chrome.storage.local.remove(["focusEndTime", "totalDuration"]);
        try {
          chrome.runtime.sendMessage({ action: "timerEnd" }, () => {
            if (chrome.runtime.lastError) {
              // Popup is closed, that's okay
            }
          });
        } catch (e) {
          // Popup is closed, that's okay
        }
      }
    }, 1000);
    
    // Create alarm for checking tabs
    chrome.alarms.create("shameCheck", { periodInMinutes: 0.2 });
    
    // Send initial timer state
    sendResponse({ success: true });
  }
  
  if (message.action === "stopFocus") {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    chrome.storage.local.remove(["focusEndTime", "totalDuration"]);
    chrome.alarms.clear("shameCheck");
    try {
      chrome.runtime.sendMessage({ action: "timerEnd" }, () => {
        if (chrome.runtime.lastError) {
          // Popup is closed, that's okay
        }
      });
    } catch (e) {
      // Popup is closed, that's okay
    }
    sendResponse({ success: true });
  }
  
  if (message.action === "getTimerState") {
    chrome.storage.local.get(["focusEndTime", "totalDuration"], (result) => {
      if (result.focusEndTime) {
        sendResponse({
          isRunning: true,
          timeLeft: Math.max(0, result.focusEndTime - Date.now()),
          totalDuration: result.totalDuration
        });
      } else {
        sendResponse({ isRunning: false });
      }
    });
    return true; // Keep the message channel open for async response
  }
});

// Respond to tab updates with debouncing
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (!tab.url) return;
  const now = Date.now();
  if (now - lastShameTime < SHAME_DEBOUNCE) return;
  checkTab(tab.url);
});

// Respond to alarms (runs in background even after popup dies)
chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name === "shameCheck") {
    const tabs = await chrome.tabs.query({});
    for (const tab of tabs) {
      if (tab.url) {
        checkTab(tab.url);
      }
    }
  }
});

// Check a URL and log failure if it's bad
async function checkTab(url) {
  const { focusEndTime } = await chrome.storage.local.get("focusEndTime");
  if (!focusEndTime || Date.now() > focusEndTime) return;

  for (const site of blockedSites) {
    if (url.includes(site)) {
      const failTime = new Date().toLocaleTimeString();
      const siteName = site.split(".")[0];

      // Inject full-screen shame message only into blocked sites
      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
      if (tabs.length > 0) {
        const tab = tabs[0];
        // Only inject if we're on a blocked site
        if (tab.url && tab.url.includes(site)) {
          try {
            await chrome.scripting.executeScript({
              target: { tabId: tab.id },
              func: () => {
                document.body.innerHTML = `
                  <div style="
                    font-family: sans-serif;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100vh;
                    font-size: 24px;
                    color: red;
                    background: black;
                    text-align: center;
                  ">
                    <h1>ðŸš¨ STOP WASTING TIME ðŸš¨</h1>
                    <p>This site is blocked during your focus session.</p>
                  </div>
                `;

                const audio = new Audio("https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg");
                audio.play().catch(() => {}); // just in case
              }
            });
          } catch (e) {
            // Ignore injection errors (e.g., if we can't inject into the page)
            console.log("Could not inject shame message:", e);
          }
        }
      }

      // Pop browser notification
      chrome.notifications.create({
        type: "basic",
        title: "ðŸ‘¿ Shame Detected",
        message: `You opened ${siteName}. Logging this disaster.`,
        priority: 2
      });

      // Log to GitHub
      await logFailure(siteName, failTime);

      // Optional: keep logging multiple times, or uncomment below to stop session
      // chrome.storage.local.remove("focusEndTime");
      // chrome.alarms.clear("shameCheck");
      break;
    }
  }
}
