import { generateShameRoast } from './gemini.js';

const blockedSites = ["youtube.com", "twitter.com", "reddit.com"];

let timerInterval;
let lastShameTime = 0;
const SHAME_DEBOUNCE = 5000; // 5 seconds between shame logs

// Function to log failure to GitHub
async function logFailure(site, time) {
  console.log("Starting logFailure for", site, "at", time);
  
  const { githubToken, githubUsername } = await chrome.storage.local.get(["githubToken", "githubUsername"]);
  let GITHUB_USERNAME = githubUsername;
  const TOKEN = githubToken;
  const REPO_NAME = "shame-log";
  const date = new Date().toISOString().split("T")[0];
  const FILE_PATH = `failed_logs/FAIL_${date}.md`;
  const newEntry = `- ${time} â€“ Visited ${site}\n`;
  const issueTitle = `Failed to focus: ${site} at ${time}`;
  
  console.log("Generating roast for issue...");
  const issueBody = await generateShameRoast(site, time);
  console.log("Generated roast:", issueBody);

  // If username isn't cached, fetch it now
  if (!GITHUB_USERNAME) {
    const userRes = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `token ${TOKEN}`,
        Accept: "application/vnd.github.v3+json"
      }
    });

    const userData = await userRes.json();
    GITHUB_USERNAME = userData.login;
    chrome.storage.local.set({ githubUsername: GITHUB_USERNAME });
  }

  // Check if repo exists
  const repoRes = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}`, {
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    }
  });

  if (repoRes.status === 404) {
    // Create the repo
    await fetch("https://api.github.com/user/repos", {
      method: "POST",
      headers: {
        Authorization: `token ${TOKEN}`,
        Accept: "application/vnd.github.v3+json"
      },
      body: JSON.stringify({
        name: REPO_NAME,
        description: "Autogenerated shame log",
        private: false,
        auto_init: true // Initialize with a README
      })
    });

    // Create failed_logs directory with .gitkeep
    await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/failed_logs/.gitkeep`, {
      method: "PUT",
      headers: {
        Authorization: `token ${TOKEN}`,
        Accept: "application/vnd.github.v3+json"
      },
      body: JSON.stringify({
        message: "chore: initialize failed_logs directory",
        content: btoa(unescape(encodeURIComponent("Directory for daily shame logs")))
      })
    });
  } else if (repoRes.status !== 200) {
    console.error("Failed to check/create repo:", await repoRes.text());
    return;
  }

  // Step 1: Create a GitHub issue
  console.log("Creating GitHub issue with roast...");
  const issueResponse = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/issues`, {
    method: "POST",
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    },
    body: JSON.stringify({
      title: issueTitle,
      body: issueBody
    })
  });

  if (!issueResponse.ok) {
    console.error("Failed to create issue:", await issueResponse.text());
    return;
  }

  const issueData = await issueResponse.json();
  console.log("Issue created:", issueData.html_url);

  // Step 2: Fetch existing log file or prepare to create it
  const fileRes = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FILE_PATH}`, {
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    }
  });

  let content = `# FAIL LOG â€“ ${date}\n\n`;
  let sha = null;

  if (fileRes.status === 200) {
    const fileData = await fileRes.json();
    try {
      content = decodeURIComponent(escape(atob(fileData.content)));
      sha = fileData.sha;
    } catch (err) {
      console.error("Failed to decode existing log file:", err);
      return;
    }
  } else if (fileRes.status !== 404) {
    console.error("GitHub file fetch failed:", await fileRes.text());
    return;
  }

  const updatedContent = btoa(unescape(encodeURIComponent(content + newEntry)));

  await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FILE_PATH}`, {
    method: "PUT",
    headers: {
      Authorization: `token ${TOKEN}`,
      Accept: "application/vnd.github.v3+json"
    },
    body: JSON.stringify({
      message: `log: failed focus on ${site}`,
      content: updatedContent,
      sha
    })
  });

  // Notify popup about shame (if it's open)
  try {
    chrome.runtime.sendMessage({
      action: "shameLogged",
      site: site,
      time: time
    }, () => {
      if (chrome.runtime.lastError) {
        // Popup is closed, that's okay
      }
    });
  } catch (e) {
    // Popup is closed, that's okay
  }
}

// Message handling
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "startFocus") {
    const minutes = message.duration;
    const totalDuration = minutes * 60;
    const endTime = Date.now() + (totalDuration * 1000);
    
    // Store timer state
    chrome.storage.local.set({
      focusEndTime: endTime,
      totalDuration: totalDuration
    });
    
    // Clear any existing timer
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    
    // Start new timer
    timerInterval = setInterval(async () => {
      const { focusEndTime } = await chrome.storage.local.get("focusEndTime");
      if (!focusEndTime) {
        clearInterval(timerInterval);
        return;
      }

      const now = Date.now();
      const timeLeft = Math.max(0, focusEndTime - now);
      
      // Update any open popups (if they exist)
      try {
        chrome.runtime.sendMessage({
          action: "timerUpdate",
          timeLeft: timeLeft
        }, () => {
          if (chrome.runtime.lastError) {
            // Popup is closed, that's okay
          }
        });
      } catch (e) {
        // Popup is closed, that's okay
      }
      
      if (timeLeft === 0) {
        clearInterval(timerInterval);
        chrome.storage.local.remove(["focusEndTime", "totalDuration"]);
        try {
          chrome.runtime.sendMessage({ action: "timerEnd" }, () => {
            if (chrome.runtime.lastError) {
              // Popup is closed, that's okay
            }
          });
        } catch (e) {
          // Popup is closed, that's okay
        }
      }
    }, 1000);
    
    // Create alarm for checking tabs
    chrome.alarms.create("shameCheck", { periodInMinutes: 0.2 });
    
    // Send initial timer state
    sendResponse({ success: true });
  }
  
  if (message.action === "stopFocus") {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    chrome.storage.local.remove(["focusEndTime", "totalDuration"]);
    chrome.alarms.clear("shameCheck");
    try {
      chrome.runtime.sendMessage({ action: "timerEnd" }, () => {
        if (chrome.runtime.lastError) {
          // Popup is closed, that's okay
        }
      });
    } catch (e) {
      // Popup is closed, that's okay
    }
    sendResponse({ success: true });
  }
  
  if (message.action === "getTimerState") {
    chrome.storage.local.get(["focusEndTime", "totalDuration"], (result) => {
      if (result.focusEndTime) {
        sendResponse({
          isRunning: true,
          timeLeft: Math.max(0, result.focusEndTime - Date.now()),
          totalDuration: result.totalDuration
        });
      } else {
        sendResponse({ isRunning: false });
      }
    });
    return true; // Keep the message channel open for async response
  }
});

// Check a URL and log failure if it's bad
async function checkTab(url, tabId) {
  const { focusEndTime, lastShamePerTab = {} } = await chrome.storage.local.get([
    "focusEndTime",
    "lastShamePerTab"
  ]);
  if (!focusEndTime || Date.now() > focusEndTime) return;

  for (const site of blockedSites) {
    if (url.includes(site)) {
      const now = Date.now();
      const last = lastShamePerTab[tabId] || 0;

      const COOLDOWN = 5000; // 5 seconds per tab
      if (now - last < COOLDOWN) return; // already shamed recently

      // Save this tab's shame time
      lastShamePerTab[tabId] = now;
      await chrome.storage.local.set({ lastShamePerTab });

      const failTime = new Date().toLocaleTimeString();
      const siteName = site.split(".")[0];

      // Continue with full shame protocol
      await logFailure(siteName, failTime);

      // Inject shame message
      try {
        await chrome.scripting.executeScript({
          target: { tabId },
          func: () => {
            document.body.innerHTML = `
              <div style="
                font-family: sans-serif;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100vh;
                font-size: 24px;
                color: red;
                background: black;
                text-align: center;
              ">
                <h1>ðŸš¨ STOP WASTING TIME ðŸš¨</h1>
                <p>This site is blocked during your focus session.</p>
              </div>
            `;
            new Audio("https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg").play();
          }
        });
      } catch (e) {
        console.log("Could not inject shame:", e);
      }

      // Notification
      chrome.notifications.create({
        type: "basic",
        iconUrl: chrome.runtime.getURL("icons/skull_lock_128.png"),
        title: "ðŸ‘¿ Shame Detected",
        message: `You opened ${siteName}. Logging this disaster.`,
        priority: 2
      });

      break;
    }
  }
}

// Listen for completed page loads
chrome.webNavigation.onCompleted.addListener(({ tabId }) => {
  chrome.tabs.get(tabId, (tab) => {
    if (tab && tab.url) {
      checkTab(tab.url, tabId);
    }
  });
});

// Respond to alarms (runs in background even after popup dies)
chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name === "shameCheck") {
    const tabs = await chrome.tabs.query({});
    for (const tab of tabs) {
      if (tab.url) {
        // Just check and block, don't log
        const { focusEndTime } = await chrome.storage.local.get("focusEndTime");
        if (!focusEndTime || Date.now() > focusEndTime) continue;

        for (const site of blockedSites) {
          if (tab.url.includes(site)) {
            // Inject full-screen shame message
            try {
              await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                func: () => {
                  document.body.innerHTML = `
                    <div style="
                      font-family: sans-serif;
                      display: flex;
                      flex-direction: column;
                      align-items: center;
                      justify-content: center;
                      height: 100vh;
                      font-size: 24px;
                      color: red;
                      background: black;
                      text-align: center;
                    ">
                      <h1>ðŸš¨ STOP WASTING TIME ðŸš¨</h1>
                      <p>This site is blocked during your focus session.</p>
                    </div>
                  `;
                }
              });
            } catch (e) {
              // Ignore injection errors
              console.log("Could not inject shame message:", e);
            }
            break;
          }
        }
      }
    }
  }
});
